# Домашнее задание к занятию "6.6. Troubleshooting"

## Задача 1

Перед выполнением задания ознакомьтесь с документацией по [администрированию MongoDB](https://docs.mongodb.com/manual/administration/).

Пользователь (разработчик) написал в канал поддержки, что у него уже 3 минуты происходит CRUD операция в MongoDB и её 
нужно прервать. 

Вы как инженер поддержки решили произвести данную операцию:
- напишите список операций, которые вы будете производить для остановки запроса пользователя

*Mongo DB предоставляет 2 варианта остановки запущенной операции -  maxTimeMS() и db.killOp(). maxTimeMS() - это метод, который устанавливает лимит времени для операции. Ставится непосредственно на операции. db.killOp()останавливает операцию на следующем прерывании по ID операции.*

https://www.mongodb.com/docs/manual/tutorial/terminate-running-operations/

*В данном случае я бы сначала нашел ID операции, используя $currentOp:*

```commandline
use admin
db.aggregate( [
   { $currentOp : { allUsers: true } },
   { $match : <filter condition> } // Optional.  Specify the condition to find the op.
                                   // e.g. { op: "getmore", "command.collection": "someCollection" }
] )

{
   "shard" : "shardB",
   ..
   "opid" : "shardB:79014",
   ...
},
{
   "shard" : "shardA",
   ..
   "opid" : "shardA:100813",
   ...
},
```

*И остановил бы их:*

```commandline
db.killOp("shardB:79014");
db.killOp("shardA:100813");
```

*Так же можно использовать killSessions:*

```commandline
db.adminCommand( { killSessions: [
   { "id" : UUID("80e48c5a-f7fb-4541-8ac0-9e3a1ed224a4"), "uid" : BinData(0,"47DEQpj8HBSa+/TImW+5JCeuQeRkm5NMpJWZG3hSuFU=") }
] } )
```

- предложите вариант решения проблемы с долгими (зависающими) запросами в MongoDB

*Первый вариант - простой. Использовать maxTimeMS() для запросов. Но тогда часть запросов, возможно будет не выполнена.*

*Второй вариант - сложнее. Использовать встроенный анализатор запросов MongoDB для выявления возможных проблем с логикой запроса или архитектурой БД.*

https://www.mongodb.com/docs/manual/tutorial/analyze-query-plan/

## Задача 2

Перед выполнением задания познакомьтесь с документацией по [Redis latency troobleshooting](https://redis.io/topics/latency).

Вы запустили инстанс Redis для использования совместно с сервисом, который использует механизм TTL. 
Причем отношение количества записанных key-value значений к количеству истёкших значений есть величина постоянная и
увеличивается пропорционально количеству реплик сервиса. 

При масштабировании сервиса до N реплик вы увидели, что:
- сначала рост отношения записанных значений к истекшим
- Redis блокирует операции записи

Как вы думаете, в чем может быть проблема?

*В росте количества истекших ключей в единицу времени.*

*Redis удаляет истекшие ключи 2 способами:*

- *Ленивый способ. Ключи удаляются при запросе к ключу, по мере обнаружения того, что они истекли.*
- *Активный способ. Истекшие ключи удаляются каждые 100 мс. Выбирает ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP истекших ключей каждый цикл. По умолчанию 20, а значит 200 ключей в секунду. Значение по умолчанию подобрано так, чтобы не сильно влиять на общую производительность, т.к. Redis однопоточное приложение.*

*Так же есть механизм, который зацикливает поиск истекших ключей. Если в найденной выборке более 25% с истекшим сроком действия Redis блокирует операции, чтобы снизить количество истекших ключей до 25% или менее.*

*Бороться с этим нужно с пониманием, почему возникает такое количество ключей в секунду. И либо менять настройки БД, либо программную логику.*
 
## Задача 3

Вы подняли базу данных MySQL для использования в гис-системе. При росте количества записей, в таблицах базы,
пользователи начали жаловаться на ошибки вида:
```python
InterfaceError: (InterfaceError) 2013: Lost connection to MySQL server during query u'SELECT..... '
```

Как вы думаете, почему это начало происходить и как локализовать проблему?

Какие пути решения данной проблемы вы можете предложить?

*Для начала убедиться, что нет сетевых проблем для уровня 4 OSI. Т.е. опорная сеть, МСЭ, балансировщики нагрузки, провайдер и/или VPN не при чем.*

*Далее читаем документацию к MySQL:*

https://dev.mysql.com/doc/refman/8.0/en/error-lost-connection.html

https://dev.mysql.com/doc/refman/8.0/en/gone-away.html

*Включаем углубленное логирование на сервере MySQL log_error_verbosity устанавливаем в 3. И анализируем логи.*

*Из условия задания, использования MySQL в гис системе делаем вывод, что возможны запросы с огромным количеством отданных строк и данные типа BLOB большого размера.*

*Если происходит передача огромного количества строк, как части одного запроса. Тогда нужно увеличить таймаут net_read_timeout с умолчательных 30 скунд до 60 или более.*

*Для передачи больших BLOB данных можно попробовать увеличить параметр max_allowed_packet на сервере (по умолчанию 64Mb для версии 8). Максимально 1Gb.*

https://dev.mysql.com/doc/refman/8.0/en/packet-too-large.html


## Задача 4


Вы решили перевести гис-систему из задачи 3 на PostgreSQL, так как прочитали в документации, что эта СУБД работает с 
большим объемом данных лучше, чем MySQL.

После запуска пользователи начали жаловаться, что СУБД время от времени становится недоступной. В dmesg вы видите, что:

`postmaster invoked oom-killer`

Как вы думаете, что происходит?

Как бы вы решили данную проблему?

*В общем это нехватка памяти сервера для поставленных задач. Ядро линукса выделяет память для процессов с избытком, в сумме превышающем наличествующую физическую память + своп. Это необходимо для лучшей масштабируемости по процессам.*

*Изучаем документацию разработчика:*

https://www.postgresql.org/docs/current/kernel-resources.html

https://www.kernel.org/doc/Documentation/vm/overcommit-accounting

*oom-killer убивает процессы, для того чтобы спасти от падения всю ОС. Причем первыми убиваются процессы с большим потреблением памяти, запущенные от непривилегированного пользователя. При запущенном PostgreSQL с большой БД - велика вероятность, что oom-killer убьет один из его процессов. Например, postmaster - супервизор.*

*Решением может быть увеличение свопа, изменение настроек  shared_buffers, work_mem, и hash_mem_multiplier в строну уменьшения. А так же уменьшение max_connections для уменьшения количества одновременных подключений и как следствие - уменьшение потребления памяти.*

*Так же возможно изменение настроек oom-killer. Установка sysctl -w vm.overcommit_memory=2 заставит ядро не разрешать выделять память для процессов с избытком. Значительно снижая вероятность, но не гарантируя сохранность процессов от окончания oom-killer. Так же, как экстримальный вариант можно совсем отключить oom-killer, но это черевато падением ОС.*

*Лучшее решение данной проблемы - разобраться почему столько процессов запускается, почему они потребляют столько памяти. Возможно на ноде есть какие-то еще задачи с потреблением памяти, которые можно переместить. Если нет, то думать в сторону расширения памяти или кластререзации СУБД с балансировкой нагрузки.*

---

### Как cдавать задание

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
